<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel= "stylesheet" type= "text/css" href= "{{ url_for('static',filename='styles/index.css') }}">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
        <title>3d-ish MineSweeper</title>
        <style>
            {{css | safe}}
        </style>
    </head>
    <body>
      <div class="statsbox">
        üö© <span id="flags">{{flagged}}</span>/<span id="total">{{totalflags}}</span><br><br>
        ‚è≤Ô∏è <span id="time">0</span> s
      </div>
      <div class="settingsbox">
        Choose Level: <br><br>
        <button id="tutorial-btn" onclick="setLevel(0)">Tutorial</button><br><br>
        <button id="beginner-btn" onclick="setLevel(1)">Beginner</button><br><br>
        <button id="intermediate-btn" onclick="setLevel(2)">Intermediate</button><br><br>
        <button id="expert-btn" onclick="setLevel(3)">Expert</button>
      </div>
        <div class="titlebox">
            <h1>3D-ish Minesweeper</h1>
            <p>Built by <a href="github.com/EdwardLuoJihan" target="_blank">me</a></p>
            <p>Enjoy!</p>
            <button onclick="resetGame(); location.reload(); resetTimer(); startTimer();">Restart</button><br><br>
            <a href="https://minesweepergame.com/strategy/how-to-play-minesweeper.php" target="_blank">How to play?</a>
        </div>
        </div>
        <div class="overlay" id="overlay">
            <div class="box">
                <h1 id='msg'>You Lost!</h1>
                <p id="timetaken"></p>
                <button onclick="resetGame(); location.reload(); resetTimer(); startTimer();">Play Again</button>
            </div>
        </div>
        <div class="grid" id="grid">
            {{html | safe}}
        </div>
        <script>
          let timer; // Variable to store the timer
let elapsedTime = parseInt(localStorage.getItem('elapsedTime')) || 0; // Track elapsed time in seconds, default to 0 if not set
let timerRunning = false; // Flag to track if the timer is running

// Function to start the timer
function startTimer() {
    if (!timerRunning) { // Only start if the timer is not already running
        timerRunning = true; // Set the flag to true
        timer = setInterval(() => {
            elapsedTime++; // Increment the elapsed time
            localStorage.setItem('elapsedTime', elapsedTime); // Store elapsed time in localStorage
            document.getElementById("time").textContent = elapsedTime; // Update the time display
        }, 1000); // Update every second
    }
}

// Function to stop the timer
function stopTimer() {
    clearInterval(timer); // Stop the timer
    timerRunning = false; // Reset the flag
}

// Load elapsed time from localStorage on page load
document.addEventListener("DOMContentLoaded", () => {
    document.getElementById("time").textContent = elapsedTime; // Display stored time
    startTimer(); // Start the timer
});

// Call this function to reset the timer when starting a new game
function resetTimer() {
    stopTimer(); // Stop the current timer
    elapsedTime = 0; // Reset elapsed time
    localStorage.removeItem('elapsedTime'); // Clear elapsed time from localStorage
    document.getElementById("time").textContent = elapsedTime; // Update the display
}


          function setLevel(level) {
        fetch("/set_level", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ level: level })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
              resetTimer();
              startTimer();
                document.getElementById("grid").innerHTML = data.html;
                document.getElementById('flags').innerText = data.flags;
                document.getElementById('total').innerText = data.nm;
            
                // Attach click event listener to each .surface element
                document.querySelectorAll('.surface').forEach(function(surface) {
                    surface.addEventListener('click', function() {
                      if (!isDragging) {
                        // Get the cell coordinates (you'll need to encode the coordinates in the div attributes)
                        const row = surface.getAttribute('data-row');
                        const col = surface.getAttribute('data-col');
            
                      const isFlagged = surface.classList.contains('flagged');
                      
            
                       if (!isFlagged) {
                         // Send a POST request to Flask with the row and column
                         fetch('/handle_click', {
                             method: 'POST',
                             headers: {
                                 'Content-Type': 'application/json'
                             },
                             body: JSON.stringify({ row: row, col: col })
                         })
                         .then(response => response.json())
                         .then(data => {
                             // Update the board or handle the Minesweeper logic based on the response
                             if (data.success) {
                                 const gameBoard = data.game_board;
            
                                 // Update the board based on revealed cells
                                 data.revealed.forEach(cell => {
                                     const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                     const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                     if (revealedCell) {
                                         revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                         const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                       if (cellValue == 0) {
                                         revealedCell.classList.add('empty');
                                         revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                       } else {
                                         if(cellValue == "M") {
                                           revealedCell.classList.add('mine');
                                         } else {

                                          if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                          
                                          revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                        }
                                       }
                                     }
                                 });
                             } else {
                               if (data.gameover) {
                                 document.getElementById('overlay').style.display = 'block';
                                 document.getElementById('msg').innerText = 'You Lost!';
                                 const gameBoard = data.game_board;
            
                                  // Update the board based on revealed cells
                                  data.revealed.forEach(cell => {
                                      const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                      const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                      if (revealedCell) {
                                          revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                          const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                        if (cellValue == 0) {
                                          revealedCell.classList.add('empty');
                                          revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                        } else {
                                          if(cellValue == "M") {
                                             revealedCell.classList.add('mine');
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                           } else {
                                            if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;}
                                        }
                                      }
                                  });
                                 resetGame()
                               }
                             }
                         })
                         .catch(error => {
                             console.error("Request failed", error);
                         });
                       }
                      } });
                  
                });
                document.querySelectorAll('.surface').forEach(function(surface) {
                surface.addEventListener('contextmenu', function(event) {
                  if (!isDragging) {
                    const row = surface.getAttribute('data-row');
                    const col = surface.getAttribute('data-col');
            
                    // Determine whether to flag or unflag
                    const isFlagged = surface.classList.contains('flagged');
            
                    // Send the request to the backend to handle flagging
                    fetch('/handle_flag', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            row: row,
                            col: col,
                            flagged: isFlagged  // If it's already flagged, we are unflagging, and vice versa
                        }),
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('flags').innerText = data.flags;
                            document.getElementById('total').innerText = data.nm;
                            // Toggle the 'flagged' class if the backend responds with success
                            if(data.state) {
                              surface.classList.add('flagged');
                            } else {
                              surface.classList.remove('flagged');
                            }
                          if (data.win) {
                            document.getElementById('overlay').style.display = 'block';
                            document.getElementById('msg').innerText = 'You Won!';
                           const gameBoard = data.game_board;
            
                           // Update the board based on revealed cells
                           data.revealed.forEach(cell => {
                               const [revealedRow, revealedCol] = cell;  // Unpack row and col
                               const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                               if (revealedCell) {
                                   revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                   const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                 if (cellValue == 0) {
                                   revealedCell.classList.add('empty');
                                   revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                 } else {
                                  if(cellValue == 'M') {
                                    revealedCell.classList.add('mine');
                                  }
                                  if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                   revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                 }
                               }
                           });
                            resetGame()
                          }
                          
                        } else {
                            console.error('Error flagging/unflagging:', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });
                  }
                });
            });
                const surfaces = document.querySelectorAll('.surface');
                
    
    surfaces.forEach((surface, index) => {
        setTimeout(() => {
          surface.style.transform = 'translate3d(0, 0, 0) rotateX(51deg) rotateZ(45deg)';
            surface.style.opacity = 1; // Reveal the surface
        }, index * 10); // Adjust the timing as needed (500ms per element)
    });

            }
        })
        .catch(error => console.error('Error:', error));
    }

document.addEventListener('DOMContentLoaded', () => {
  startTimer();
    const surfaces = document.querySelectorAll('.surface');
    
    surfaces.forEach((surface, index) => {
        setTimeout(() => {
          surface.style.transform = 'translate3d(0, 0, 0) rotateX(51deg) rotateZ(45deg)';
            surface.style.opacity = 1; // Reveal the surface
        }, index * 10); // Adjust the timing as needed (500ms per element)
    });
});
            window.addEventListener('wheel', function(event) {
                event.preventDefault();
            }, { passive: false });
            
            
            // Disable zoom on all devices
            document.addEventListener('wheel', function(event) {
              if (event.ctrlKey) {
                event.preventDefault();
              }
            }, { passive: false });
            
            document.addEventListener('keydown', function(event) {
              if (event.ctrlKey && (event.key === '+' || event.key === '-' || event.key === '0')) {
                event.preventDefault();
              }
            });
            // Make the DIV element draggable:
            dragElement(document.getElementById("grid"));
            
            // Call the function to make the body draggable
            dragBody();
            let isDragging = false;
            
            function dragElement(elmnt) {
              var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
              // Move the DIV from anywhere inside the DIV:
              elmnt.onmousedown = dragMouseDown;
            
              function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                document.body.style.cursor = "grabbing";
                isDragging = true;
                // get the mouse cursor position at startup:
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = elementDrag;
                
              }
            
              function elementDrag(e) {
                  e = e || window.event;
                  e.preventDefault();
            
                  // calculate the new cursor position:
                  pos1 = pos3 - e.clientX;
                  pos2 = pos4 - e.clientY;
                  pos3 = e.clientX;
                  pos4 = e.clientY;
            
                  // Get the current position and dimensions of the grid
                  const grid = elmnt;
                  const gridRect = grid.getBoundingClientRect();
                  const viewportWidth = window.innerWidth;
                  const viewportHeight = window.innerHeight;
            
                  // Calculate new position
                  let newTop = grid.offsetTop - pos2;
                  let newLeft = grid.offsetLeft - pos1;
            
                  // Ensure at least part of the grid is within the viewport
                  if (newTop + gridRect.height < 0) {
                      newTop = -gridRect.height + 1; // Allow the grid to be dragged slightly outside at the top
                  } else if (newTop > viewportHeight) {
                      newTop = viewportHeight - 1; // Allow the grid to be dragged slightly outside at the bottom
                  }
            
                  if (newLeft + gridRect.width < 0) {
                      newLeft = -gridRect.width + 1; // Allow the grid to be dragged slightly outside on the left
                  } else if (newLeft > viewportWidth) {
                      newLeft = viewportWidth - 1; // Allow the grid to be dragged slightly outside on the right
                  }
            
                  // Ensure at least part of the grid is visible in the viewport
                  if (newTop > 100) {
                      newTop = Math.max(0, newTop); // Limit to top if fully visible
                  } else if (newTop + gridRect.height < viewportHeight) {
                      newTop = Math.min(viewportHeight - gridRect.height, newTop); // Limit to bottom if fully visible
                  }
            
                  if (newLeft > 0) {
                      newLeft = Math.max(0, newLeft); // Limit to left if fully visible
                  } else if (newLeft + gridRect.width < viewportWidth) {
                      newLeft = Math.min(viewportWidth - gridRect.width, newLeft); // Limit to right if fully visible
                  }
            
                  // set the element's new position:
                  grid.style.top = newTop + "px";
                  grid.style.left = newLeft + "px";
              }
            
              function closeDragElement() {
                // stop moving when mouse button is released:
                document.onmouseup = null;
                isDragging = false;
                document.onmousemove = null;
                document.body.style.cursor = "grab";
              }
            }
            
            function dragBody() {
              var body = document.body;
              var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
              body.onmousedown = dragMouseDown;
            
              function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // get the mouse cursor position at startup:
                document.body.style.cursor = "grabbing";
                isDragging = true;
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = bodyDrag;
              }
            
              function bodyDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // calculate the new cursor position:
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
            
                // Get the current position and dimensions of the grid
                const grid = document.getElementById("grid");
                const gridRect = grid.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
            
                // Calculate new position
                let newTop = grid.offsetTop - pos2;
                let newLeft = grid.offsetLeft - pos1;
            
                // Ensure at least part of the grid is within the viewport
                if (newTop + gridRect.height < 0) {
                  newTop = -gridRect.height + 1; // Allow the grid to be dragged slightly outside at the top
                } else if (newTop > viewportHeight) {
                  newTop = viewportHeight - 1; // Allow the grid to be dragged slightly outside at the bottom
                }
            
                if (newLeft + gridRect.width < 0) {
                  newLeft = -gridRect.width + 1; // Allow the grid to be dragged slightly outside on the left
                } else if (newLeft > viewportWidth) {
                  newLeft = viewportWidth - 1; // Allow the grid to be dragged slightly outside on the right
                }
            
                // Ensure at least part of the grid is visible in the viewport
                if (newTop > 0) {
                  newTop = Math.max(0, newTop); // Limit to top if fully visible
                } else if (newTop + gridRect.height < viewportHeight) {
                  newTop = Math.min(viewportHeight - gridRect.height, newTop); // Limit to bottom if fully visible
                }
            
                if (newLeft > 0) {
                  newLeft = Math.max(0, newLeft); // Limit to left if fully visible
                } else if (newLeft + gridRect.width < viewportWidth) {
                  newLeft = Math.min(viewportWidth - gridRect.width, newLeft); // Limit to right if fully visible
                }
            
                // set the grid's new position:
                grid.style.top = newTop + "px";
                grid.style.left = newLeft + "px";
              }
            
              function closeDragElement() {
                // stop moving when mouse button is released:
                document.onmouseup = null;
                document.onmousemove = null;
                document.body.style.cursor = "grab";
                isDragging = false;
              }
            }
            
            document.addEventListener('contextmenu', function(event) {
                event.preventDefault();
            });
            document.querySelectorAll('.surface').forEach(function(surface) {
                surface.addEventListener('contextmenu', function(event) {
            
                  if (!isDragging) {
                    const row = surface.getAttribute('data-row');
                    const col = surface.getAttribute('data-col');
            
                    // Determine whether to flag or unflag
                    const isFlagged = surface.classList.contains('flagged');
            
                    // Send the request to the backend to handle flagging
                    fetch('/handle_flag', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            row: row,
                            col: col,
                            flagged: isFlagged  // If it's already flagged, we are unflagging, and vice versa
                        }),
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('flags').innerText = data.flags;
                            document.getElementById('total').innerText = data.nm;
                            // Toggle the 'flagged' class if the backend responds with success
                            if(data.state) {
                              surface.classList.add('flagged');
                            } else {
                              surface.classList.remove('flagged');
                            }
                          if (data.win) {
                            document.getElementById('overlay').style.display = 'block';
                            document.getElementById('msg').innerText = 'You Won!';
                            stopTimer();
                            document.getElementById('timetaken').innerHTML = `Time Taken: <span id='t'>${elapsedTime}</span> s <br><br>`;
                           const gameBoard = data.game_board;
            
                           // Update the board based on revealed cells
                           data.revealed.forEach(cell => {
                               const [revealedRow, revealedCol] = cell;  // Unpack row and col
                               const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                               if (revealedCell) {
                                   revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                   const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                 if (cellValue == 0) {
                                   revealedCell.classList.add('empty');
                                   revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                 } else {
                                  if(cellValue == 'M') {
                                    revealedCell.classList.add('mine');
                                  }
                                  if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                   revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                 }
                               }
                           });
                            resetGame()
                          }
                          
                        } else {
                            console.error('Error flagging/unflagging:', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });
                  }
                });
            });
            document.addEventListener('DOMContentLoaded', function() {
                // Get all elements with the class 'surface'
                const surfaces = document.querySelectorAll('.surface');
            
                // Attach click event listener to each .surface element
                surfaces.forEach(function(surface) {
                    surface.addEventListener('click', function() {
                      if (!isDragging) {
                        // Get the cell coordinates (you'll need to encode the coordinates in the div attributes)
                        const row = surface.getAttribute('data-row');
                        const col = surface.getAttribute('data-col');
            
                      const isFlagged = surface.classList.contains('flagged');
                      
            
                       if (!isFlagged) {
                         // Send a POST request to Flask with the row and column
                         fetch('/handle_click', {
                             method: 'POST',
                             headers: {
                                 'Content-Type': 'application/json'
                             },
                             body: JSON.stringify({ row: row, col: col })
                         })
                         .then(response => response.json())
                         .then(data => {
                             // Update the board or handle the Minesweeper logic based on the response
                             if (data.success) {
                                 const gameBoard = data.game_board;
            
                                 // Update the board based on revealed cells
                                 data.revealed.forEach(cell => {
                                     const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                     const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                     if (revealedCell) {
                                         revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                         const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                       if (cellValue == 0) {
                                         revealedCell.classList.add('empty');
                                         revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                       } else {
                                         if(cellValue == "M") {
                                           revealedCell.classList.add('mine');
                                         } else {

                                          if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                          
                                          revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                        }
                                       }
                                     }
                                 });
                             } else {
                               if (data.gameover) {
                                 document.getElementById('overlay').style.display = 'block';
                                 document.getElementById('msg').innerText = 'You Lost!';
                                 const gameBoard = data.game_board;
            
                                  // Update the board based on revealed cells
                                  data.revealed.forEach(cell => {
                                      const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                      const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                      if (revealedCell) {
                                          revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                          const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                        if (cellValue == 0) {
                                          revealedCell.classList.add('empty');
                                          revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                        } else {
                                          if(cellValue == "M") {
                                             revealedCell.classList.add('mine');
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                           } else {
                                            if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;}
                                        }
                                      }
                                  });
                                 resetGame()
                               }
                             }
                         })
                         .catch(error => {
                             console.error("Request failed", error);
                         });
                       }
                      } });
                  
                });
            });
            function resetGame() {
                fetch('/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update the HTML with the new game state
                        document.querySelector('.game-board').innerHTML = data.html;
                        document.getElementById('game-message').innerText = ""; // Clear any game messages
                    } else {
                        console.error('Error resetting the game:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }
        </script>
    </body>
</html>